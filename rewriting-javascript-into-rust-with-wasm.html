<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Blog - Jaroslaw Weber</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">
    <script defer src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Mina" rel="stylesheet">


    <!-- highlighting syntax-->
    <link rel="stylesheet" href="static/highlight/styles/github.css">
    <script src="static/highlight/highlight.pack.js"></script>
    <!---->

    <link rel="stylesheet" href="static/style.css">
    

</head>

<body>
    <section class="hero primary">
    <nav class="navbar" role="navigation" aria-label="main navigation">
        <div class="navbar-brand">
            <div class="navbar-item primary"><i class="fas fa-plane"></i></div>
            <a class="navbar-item primary" href="https://jaroslaw-weber.github.io/blog">Blog</a>
            <div class="navbar-item primary"><i class="fas fa-cloud"></i></div>
            <a class="navbar-item primary" href="https://jaroslaw-weber.github.io">Portfolio</a>
        </div>
    </nav>
</section>
    <section class="section">
        <div class="container narrow content">
            <!-- post content -->
            <h1 class="title has-text-centered primary-text">Rewriting javascript into rust with wasm</h1>
            <p>Wasm (Web Assembly) is a new technology allowing people to use languages other than javascript inside browser.
Wasm allows to not only use another languages but also creates possibility to improve performance.
Rust programming language is currently heavily investing in easy deploying wasm applications.
I decided to try rewrite my javascript front-end script with Rust and wasm and see what is possible.
</p>
<br>
            <div class="has-text-centered">
            <br>
                <img class="article-image" src="https://image.freepik.com/free-vector/businessmen-with-a-rocket_1133-282.jpg">
                <br> <a href='https://www.freepik.com/free-vector/businessmen-with-a-rocket_1076087.htm'>Designed by Freepik</a>

            </div>
            <h1 class="title bigtext primary-text">Why</h1>
<p class="text">I have a static website on github pages. I was using small javascript script to write custom &quot;html form to toml formatter&quot;. The site is simple, you fill the form and click &quot;save&quot; button and it saves the contents of the form to toml file.</p>
<p class="text">I used &quot;moment.js&quot; for parsing date and &quot;filesaver.js&quot; for saving files. I started to use few outside libraries so I was thinking about going from plain javascript to npm (node package manager) project. But I didn't want to mess with npm just yet. My custom formatter was mostly working, but had some bugs. I was deciding between using npm or trying wasm. I decided it could be interesting experiment to write front-end with Rust. It is great language, and it is much easier to maintain than javascript.</p>
<p class="text">So I rewrote my javascript to Rust.</p>
<h1 class="title bigtext primary-text">SEO &amp; macros formating vs going full rust</h1>
<p class="text">I found out about quasar and yew. Great projects. But I didn't want to make a one page application. I would need to load everything before displaying a website which is not good for user experience, especially on small site targeted for both pc and mobile. Also, I wanted to stay SEO friendly as much as possible. So I decided to go the &quot;jQuery way&quot; - create static page and manipulate it later.</p>
<p class="text">For creating static page I used site generation library I created - <a href="https://github.com/jaroslaw-weber/slime">slime</a>. It loads data from toml files and put it inside handlebars templates.</p>
<p class="text">For dom manipulation I used stdweb.</p>
<h1 class="title bigtext primary-text">quasar</h1>
<p class="text">Quasar is one framework for writing front-end web applications with rust.</p>
<p class="text"><a href="https://github.com/anowell/quasar">https://github.com/anowell/quasar</a></p>
<p class="text">Example code:</p>
<pre><code class="language-rust">#[derive(Default, BartDisplay)]
#[template_string = &quot;&lt;p&gt;Count: {{count}}&lt;/p&gt;&lt;button&gt;+1&lt;/button&gt;&quot;]
struct CounterData { count: u32 }

impl Component for CounterData {
    fn onload(view: &amp;View&lt;Self&gt;) {
        view.on_each(EventType::Click, &quot;button&quot;, |mut evt| {
              evt.binding.data_mut().count += 1;
        });
    }
}

fn main() {
    let mut app = quasar::init();
    app.bind(&quot;#counter&quot;, CounterData::default());
    app.spin();
}
</code></pre>
<p class="text">It is quite straightforward and looks really nice, but as I already said, I needed to only manipulate dom, not create everything from scratch.</p>
<h1 class="title bigtext primary-text">yew</h1>
<p class="text">Yew is another library for doing front-end with Rust.</p>
<p class="text"><a href="https://github.com/DenisKolodin/yew">https://github.com/DenisKolodin/yew</a></p>
<p class="text">It is quite similar to quasar but little more verbose. It is currently the most popular library for writing front-end in Rust (about 4000 stars, over 100 forks). It has a lot of examples. This is probably the best choice right now.</p>
<h1 class="title bigtext primary-text">stdweb</h1>
<p class="text"><a href="https://github.com/koute/stdweb">https://github.com/koute/stdweb</a></p>
<p class="text">Stdweb is just a wrapper around a plain javascript. It is mostly mapping things like &quot;querySelector&quot; or &quot;.childNodes()&quot; into rust syntax. It also has 'js!' macro which allows you to write javascript inside Rust file. It is very simple but powerful library. It is still lacking the functionality but you can do a lot of things with plain rust, and fill the holes with 'js!' macro.</p>
<p class="text">Macro example:</p>
<pre><code class="language-rust">let name = &quot;Peter&quot;;
let age = 30;
js! {
    var person = @{person};
    console.log( @{name} + &quot; is &quot; + @{age} + &quot; years old.&quot; );
};
</code></pre>
<p class="text">Super easy, right?</p>
<p class="text">Example of querying inside rust:</p>
<pre><code class="language-rust">
let inputs = form.query_selector_all(&quot;input&quot;).expect(&quot;no input&quot;);
</code></pre>
<p class="text">Same as javascript. It was mostly like writing javascript with types.</p>
<h1 class="title bigtext primary-text">Datetime problem</h1>
<p class="text">So the <code>chrono</code> crate did not compile. <code>chrono</code> is using <code>std::time</code>. It is possible to use chrono with wasm, but I cannot use <code>time</code> so I cannot get current time. This was great obstacle for me, as I was planning to add timestamp into my toml files. The easiest way was just using <code>moment.js</code> like this:</p>
<pre><code class="language-rust">using toml::value::DateTime;

fn get_time() -&gt; String {
    js! (
        return moment().format();
    ).try_into()
        .expect(&quot;failed to get time&quot;)
}

...
let time_string = get_time();
let time = Datetime::from_str(&amp;time_string)
    .expect(&quot;failed to parse date&quot;);
</code></pre>
<p class="text">So I was able to find quite easy workaround. Although, I wish I could do it with only Rust.</p>
<h1 class="title bigtext primary-text">File size</h1>
<p class="text">The other problem was file size. My website was loading slowly. So I assumed it was because of the size of wasm file (300kb). Well, the problem was, I accidentally copy-pasted &quot;font-awesome&quot; font into header (...) . It was not so awesome, it was blocking the loading of my page. Anyway, I did not notice at first so I tried to reduce the wasm size. With some config parameters and changing allocator to something smaller, I got down to 220kb.</p>
<p class="text">Here was my new config file:</p>
<pre><code class="language-toml">[dependencies]
stdweb = &quot;0.4.4&quot;
toml = &quot;0.4.6&quot;
wee_alloc = &quot;0.4.0&quot;

[profile.release]
lto = true
opt-level = 'z' # `s` or 'z'
debug = false
</code></pre>
<p class="text">Not bad, especially that it is loading in the background asynchronously (so it will load before you fill the form!). I was actually able to get it down to about 160kb with wasm-opt.</p>
<p class="text">There is actually a page, where you can read about this stuff:</p>
<p class="text"><a href="https://rust-lang-nursery.github.io/rust-wasm/game-of-life/code-size.html">Optimising wasm file size</a></p>
<h1 class="title bigtext primary-text">It is working! But...</h1>
<p class="text">I builded the script, uploaded on Github.</p>
<p class="text"><a href="https://cbt-diary.github.io/">Github Pages - here</a></p>
<p class="text"><a href="https://github.com/jaroslaw-weber/cbt-diary">Source Code - here</a></p>
<p class="text">The script is working and site is loading fast (because the wasm script is loaded asynchronously). The whole page size (without wasm) is 65kb. Not bad!
How would I make it even smaller? &quot;moment.js&quot; library is 32kb. I could load it asynchronously.</p>
<p class="text">By the way, the javascript file generated with cargo web is 5kb so it is really small.</p>
<p class="text">Still, we need to wait for the load of wasm file which is about 200kb.</p>
<p class="text">So the site is working! Kind of. I am using adblock plugin (ublock origin) and it blocks files with .wasm extension. It is easy to do a client side workaround (turn off the adblock or fix the adblock rule) but explaining this to user is making the user experience little worse.</p>
<h1 class="title bigtext primary-text">Trust</h1>
<p class="text">The other painpoint of wasm is that it is not readable. With javascript, we can see the source inside the browser. Yes, you can check the code on the github, but it is more difficult to confirm &quot;safety&quot; of the code, than pure javascript implementation.</p>
<p class="text">My website is handling some sensitive data and user don't want the data to be stored anywhere. Before, I could say to him &quot;look at the source code in the browser&quot; to assure that I don't do anything suspicious, but currently I can recommend &quot;turning off the wifi&quot; or checking the source code on Github.</p>
<h1 class="title bigtext primary-text">Build times again...</h1>
<p class="text">Unfortunately, my build times got much longer. I was only using plain javascript before so there was no &quot;build step&quot;. It is taking 17 minutes now, even with caching cargo in travis.</p>
<h1 class="title bigtext primary-text">Same page, second app</h1>
<p class="text">I wanted to also create script for analysing the toml files. I wanted to have it as a separate project from the &quot;form to toml&quot; part. So I created new project.</p>
<h1 class="title bigtext primary-text">Mysterious bug, bad mutex and disappearing errors</h1>
<p class="text">I wanted user to be able to upload multiple times at the same time and update the dom as the file is ready.</p>
<p class="text">Working on my script I started getting mysterious error:</p>
<pre><code>RuntimeError: unreachable executed
</code></pre>
<p class="text">Until some time ago everything was working and outputing nice panic messages. But something changed and all errors became one.</p>
<p class="text">So I asked my friend google what is going on and found this:</p>
<p class="text"><a href="https://github.com/jakedeichert/wasm-astar">https://github.com/jakedeichert/wasm-astar</a></p>
<p class="text">The problem was... mutex locks. I added mutex when I decided to add asynchronous behaviour inside my app. After fixing all bugs in my code everything was working. So I was able to stop error from appearing but it will probably come back if I create bug somewhere. It was not great to debug, unfortunately.</p>
<h1 class="title bigtext primary-text">Cross-platform GUI solution?</h1>
<p class="text">Wasm may be THE way to create cross-platform GUI apps with Rust. It is cross-platform, you don't need to pack whole browser to use it (lighter than electron), and it is easy to build (with some wrappers like yew/quasar). It is also easy to write because we don't need to learn new library, we can just use &quot;old plain html with css&quot;. You could also post it on github pages for free.</p>
<h1 class="title bigtext primary-text">My experience with WebAssembly</h1>
<p class="text">It did not take me long to find out how to start a wasm project. The setup was not compilicated (especially with wasm-unknown-unknown target available!). Stdweb was quite straightforward.
I was suprised how easy it was to write front-end in Rust.</p>
<p class="text">The problem may be some crates not working (&quot;chrono&quot;) on wasm yet. Still, you can find some workarounds with javascript libraries.</p>
<p class="text">I wonder if Rust will have more &quot;wasm-only&quot; libraries in the future. Lot of libraries are not optimising their codebase for binary size. We could use some &quot;light&quot; versions of libraries. The binary size in wasm is very important.</p>
<p class="text">The overall experience with wasm was great. I see a great potential in it and hope yew/quasar libraries get better.</p>

            <!-- post content -->
        </div>
    </section>
    <section class="section">
    <div class="container">
        <hr>
        <footer>
            <div class="has-text-centered">
                <p class="title">contact</p>
                <a class="button" href="mailto:jaroslaw.weber@gmail.com">jaroslaw.weber@gmail.com</a>
            </div>
        </footer>
    </div>
</section>
    <script>hljs.initHighlightingOnLoad();</script>

</body>

</html>